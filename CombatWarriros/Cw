-- Lock-on UI with "Always Nearest" / "Toggle Nearest" modes + draggable toggle button
-- Executor-friendly; client-side rotation and highlight (chams)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- CONFIG
local ROTATE_SMOOTH = 1 -- 1 = instant rotation, smaller -> snappier. Use 0.2 for smoothing if you want (we'll lerp)
local AUTO_START_AFTER_MODE_CLICK = true
local MODE_CLICK_DELAY = 1.5

-- STATE
local mode = "Toggle"      -- "Toggle" or "Always"
local Locking = false
local LockedTarget = nil
local HighlightHandle = nil

-- UI: Main rounded panel
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "LockModeSelectorGui"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = PlayerGui

local panel = Instance.new("Frame")
panel.Size = UDim2.new(0, 340, 0, 140)
panel.Position = UDim2.new(0.02, 0, 0.15, 0)
panel.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
panel.BorderSizePixel = 0
panel.Parent = screenGui
local panelCorner = Instance.new("UICorner", panel)
panelCorner.CornerRadius = UDim.new(0, 14)

local title = Instance.new("TextLabel", panel)
title.Size = UDim2.new(1, -20, 0, 36)
title.Position = UDim2.new(0, 10, 0, 10)
title.BackgroundTransparency = 1
title.Text = "Which Lock Do You Want?"
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(230,230,230)
title.TextXAlignment = Enum.TextXAlignment.Left

-- Container for buttons
local buttonsFrame = Instance.new("Frame", panel)
buttonsFrame.Size = UDim2.new(1, -20, 0, 70)
buttonsFrame.Position = UDim2.new(0, 10, 0, 54)
buttonsFrame.BackgroundTransparency = 1

local function makeModeButton(parent, xOffset, text)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(0, 150, 0, 60)
    btn.Position = UDim2.new(0, xOffset, 0, 0)
    btn.Text = text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 16
    btn.TextColor3 = Color3.fromRGB(240,240,240)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,50)
    btn.BorderSizePixel = 0
    local c = Instance.new("UICorner", btn)
    c.CornerRadius = UDim.new(0, 10)
    return btn
end

local alwaysBtn = makeModeButton(buttonsFrame, 0, "Always Nearest")
local toggleBtn = makeModeButton(buttonsFrame, 170, "Toggle Nearest")

-- Small status label
local statusLabel = Instance.new("TextLabel", panel)
statusLabel.Size = UDim2.new(1, -20, 0, 18)
statusLabel.Position = UDim2.new(0, 10, 1, -26)
statusLabel.BackgroundTransparency = 1
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 14
statusLabel.TextColor3 = Color3.fromRGB(180,180,180)
statusLabel.Text = "Mode: Toggle | Lock: OFF"
statusLabel.TextXAlignment = Enum.TextXAlignment.Left

-- Draggable toggle button (small, rounded)
local lockToggle = Instance.new("TextButton")
lockToggle.Name = "LockToggleBtn"
lockToggle.Size = UDim2.new(0, 80, 0, 40)
lockToggle.Position = UDim2.new(0.5, -40, 0.85, 0)
lockToggle.AnchorPoint = Vector2.new(0.5, 0)
lockToggle.BackgroundColor3 = Color3.fromRGB(60,60,60)
lockToggle.TextColor3 = Color3.fromRGB(255,255,255)
lockToggle.Font = Enum.Font.GothamBold
lockToggle.TextSize = 16
lockToggle.Text = "ðŸ”’ OFF"
local corner = Instance.new("UICorner", lockToggle)
corner.CornerRadius = UDim.new(0, 10)
lockToggle.Parent = screenGui

-- Make panel draggable
local draggingPanel, dragStart, startPos = false, nil, nil
panel.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        draggingPanel = true
        dragStart = input.Position
        startPos = panel.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                draggingPanel = false
            end
        end)
    end
end)
panel.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)
UIS.InputChanged:Connect(function(input)
    if draggingPanel and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        panel.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Make toggle draggable
local draggingToggle, toggleDragStart, toggleStartPos, toggleInput
lockToggle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        draggingToggle = true
        toggleDragStart = input.Position
        toggleStartPos = lockToggle.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                draggingToggle = false
                toggleInput = nil
            end
        end)
    end
end)
lockToggle.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        toggleInput = input
    end
end)
UIS.InputChanged:Connect(function(input)
    if draggingToggle and input == toggleInput then
        local delta = input.Position - toggleDragStart
        lockToggle.Position = UDim2.new(toggleStartPos.X.Scale, toggleStartPos.X.Offset + delta.X, toggleStartPos.Y.Scale, toggleStartPos.Y.Offset + delta.Y)
    end
end)

-- Helper: get nearest valid player
local function getNearestPlayer()
    local closest, dist = nil, math.huge
    local myChar = LocalPlayer.Character
    if not myChar or not myChar.Parent then return nil end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local myPos = myHRP.Position
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character.Parent and pl.Character:FindFirstChild("HumanoidRootPart") and pl.Character:FindFirstChild("Humanoid") then
            local hum = pl.Character:FindFirstChild("Humanoid")
            if hum and hum.Health > 0 then
                local targetPos = pl.Character.HumanoidRootPart.Position
                local mag = (myPos - targetPos).Magnitude
                if mag < dist then
                    dist = mag
                    closest = pl
                end
            end
        end
    end
    return closest
end

-- Highlight (chams) handling
local function clearHighlight()
    if HighlightHandle then
        pcall(function() HighlightHandle:Destroy() end)
        HighlightHandle = nil
    end
end

local function applyHighlightToCharacter(char)
    clearHighlight()
    if not char then return end
    local h = Instance.new("Highlight")
    h.Adornee = char
    h.FillColor = Color3.fromRGB(255, 40, 40)
    h.OutlineColor = Color3.fromRGB(255,255,255)
    h.FillTransparency = 0.25
    h.OutlineTransparency = 0
    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    h.Parent = game:GetService("CoreGui")
    HighlightHandle = h
end

-- Rotation function (preserve Y position; optional smoothing)
local function rotateCharacterTowards(targetPos)
    local char = LocalPlayer.Character
    if not char or not char.Parent then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local p = hrp.Position
    local dir = (Vector3.new(targetPos.X, p.Y, targetPos.Z) - p)
    if dir.Magnitude <= 0 then return end
    local targetCFrame = CFrame.new(p, p + dir.Unit)
    -- instant set or smooth lerp
    if ROTATE_SMOOTH >= 0.999 then
        hrp.CFrame = targetCFrame
    else
        local current = hrp.CFrame
        -- simple slerp style for yaw only
        local newCFrame = current:Lerp(targetCFrame, math.clamp(1 - ROTATE_SMOOTH * 0.75, 0.01, 1))
        hrp.CFrame = newCFrame
    end
end

-- Core lock behavior handled every frame
RunService.RenderStepped:Connect(function()
    if not Locking then return end

    -- if no valid locked target or dead -> pick according to mode
    local validTarget = LockedTarget and LockedTarget.Character and LockedTarget.Character.Parent and LockedTarget.Character:FindFirstChild("Humanoid") and LockedTarget.Character.Humanoid.Health > 0

    if mode == "Always" then
        -- Always pick nearest every frame (auto switch)
        local nearest = getNearestPlayer()
        if nearest ~= LockedTarget then
            LockedTarget = nearest
            if LockedTarget and LockedTarget.Character then
                applyHighlightToCharacter(LockedTarget.Character)
            else
                clearHighlight()
            end
        end
    else -- "Toggle" mode
        if not validTarget then
            LockedTarget = getNearestPlayer()
            if LockedTarget then
                applyHighlightToCharacter(LockedTarget.Character)
            else
                clearHighlight()
            end
        end
    end

    -- If we have a locked target, rotate toward them
    if LockedTarget and LockedTarget.Character and LockedTarget.Character:FindFirstChild("HumanoidRootPart") then
        local tpos = LockedTarget.Character.HumanoidRootPart.Position
        rotateCharacterTowards(tpos)
        statusLabel.Text = ("Mode: %s | Lock: ON -> %s"):format(mode == "Always" and "Always" or "Toggle", LockedTarget.Name or "Unknown")
    else
        statusLabel.Text = ("Mode: %s | Lock: ON (no target)"):format(mode == "Always" and "Always" or "Toggle")
    end
end)

-- Toggle logic for lock button
local function setLocking(on)
    Locking = on
    if not on then
        LockedTarget = nil
        clearHighlight()
        lockToggle.Text = "ðŸ”’ OFF"
        lockToggle.BackgroundColor3 = Color3.fromRGB(60,60,60)
        statusLabel.Text = ("Mode: %s | Lock: OFF"):format(mode == "Always" and "Always" or "Toggle")
    else
        -- Lock now depending on mode
        if mode == "Always" then
            LockedTarget = getNearestPlayer()
            if LockedTarget then applyHighlightToCharacter(LockedTarget.Character) end
        else
            LockedTarget = getNearestPlayer()
            if LockedTarget then applyHighlightToCharacter(LockedTarget.Character) end
        end
        lockToggle.Text = "ðŸ”’ ON"
        lockToggle.BackgroundColor3 = Color3.fromRGB(160,30,30)
    end
end

-- Click handlers for the two mode buttons
local function modeButtonClicked(selectedMode)
    mode = selectedMode -- "Always" or "Toggle"
    -- Update UI to show selection
    if mode == "Always" then
        alwaysBtn.BackgroundColor3 = Color3.fromRGB(70,70,80)
        toggleBtn.BackgroundColor3 = Color3.fromRGB(40,40,50)
    else
        toggleBtn.BackgroundColor3 = Color3.fromRGB(70,70,80)
        alwaysBtn.BackgroundColor3 = Color3.fromRGB(40,40,50)
    end

    -- After MODE_CLICK_DELAY, execute optional loadstring and optionally auto-start locking
    task.spawn(function()
        task.wait(MODE_CLICK_DELAY)
        -- Directly run your loadstring after 1.5 sec wait
        pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/ddario66/Test/refs/heads/main/Combat%20warrior"))()
        end)


        -- Optionally auto-start lock after selecting mode
        if AUTO_START_AFTER_MODE_CLICK then
            setLocking(true)
        end
    end)
end

alwaysBtn.MouseButton1Click:Connect(function() modeButtonClicked("Always") end)
toggleBtn.MouseButton1Click:Connect(function() modeButtonClicked("Toggle") end)

-- Toggle button click (user can also manually toggle)
lockToggle.MouseButton1Click:Connect(function()
    setLocking(not Locking)
end)

-- Clean up highlight when player leaves or script destroyed
Players.PlayerRemoving:Connect(function(p)
    if LockedTarget and p == LockedTarget then
        LockedTarget = nil
        clearHighlight()
    end
end)

-- Safety: clear highlight on character respawn
LocalPlayer.CharacterRemoving:Connect(function()
    clearHighlight()
    LockedTarget = nil
end)

-- initial UI state
-- select Toggle as default
modeButtonClicked("Toggle")
-- but since modeButtonClicked auto-starts locking by default, set to off if you prefer:
-- setLocking(false)

-- END
