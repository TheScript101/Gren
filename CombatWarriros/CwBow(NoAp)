local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = workspace.CurrentCamera

-- config
local ROTATE_SMOOTH = 1           
local MODE_CLICK_DELAY = 1.5      
local AUTO_START_AFTER_MODE_CLICK = true

-- smoothing config for camera lerp (higher = faster response)
local CAM_SMOOTHNESS = 3.5 -- you can tweak this (6 is "a bit fast" feel)

-- state
local mode = "Toggle"             
local Locking = false
local LockedTarget = nil
local HighlightHandle = nil
local camLockEnabled = false -- existing: instant camera snap
local camSmoothMode = false  -- existing: smooth camera orientation mode
local aimHeadEnabled = false -- existing: aim head toggle (replaced old wall-check)
local smoothSwitching = false -- NEW: active while Smooth CamLock is transitioning

-- UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "LockModeSelectorGui"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = PlayerGui

local panel = Instance.new("Frame", screenGui)
panel.Size = UDim2.new(0, 500, 0, 280) -- ENLARGED slightly to fit new button
panel.Position = UDim2.new(0.0199999996, 169, 0.050000006, 92)
panel.BackgroundColor3 = Color3.fromRGB(20,20,25)
panel.BorderSizePixel = 0
panel.Active = true
local panelCorner = Instance.new("UICorner", panel)
panelCorner.CornerRadius = UDim.new(0, 14)

local title = Instance.new("TextLabel", panel)
title.Size = UDim2.new(1, -20, 0, 36)
title.Position = UDim2.new(0, 10, 0, 10)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(230,230,230)
title.TextXAlignment = Enum.TextXAlignment.Left
title.Text = "Which Lock Do You Want?"

local buttonsFrame = Instance.new("Frame", panel)
buttonsFrame.Size = UDim2.new(1, -20, 0, 250) -- ENLARGED height to allow one more row
buttonsFrame.Position = UDim2.new(0, 10, 0, 54)
buttonsFrame.BackgroundTransparency = 1

local function makeModeButton(parent, xOffset, yOffset, text)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(0, 230, 0, 40)
    btn.Position = UDim2.new(0, xOffset, 0, yOffset)
    btn.Text = text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 16
    btn.TextColor3 = Color3.fromRGB(240,240,240)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,50)
    btn.BorderSizePixel = 0
    return btn
end

-- original 2 buttons
local alwaysBtn = makeModeButton(buttonsFrame, 0, 0, "Always Nearest")
local toggleBtn = makeModeButton(buttonsFrame, 240, 0, "Toggle Nearest")

-- camlock buttons
local alwaysCamBtn = makeModeButton(buttonsFrame, 0, 50, "Always CamLock")
local toggleCamBtn = makeModeButton(buttonsFrame, 240, 50, "Toggle CamLock")

-- Always Smooth button
local alwaysSmoothBtn = makeModeButton(buttonsFrame, 0, 100, "Always Smooth")

-- AimHead toggle button
local aimHeadBtn = makeModeButton(buttonsFrame, 240, 100, "AimHead: OFF")

-- NEW: Smooth CamLock button (new 4th row)
local smoothCamBtn = makeModeButton(buttonsFrame, 0, 150, "Smooth CamLock")

local statusLabel = Instance.new("TextLabel", panel)
statusLabel.Size = UDim2.new(1, -20, 0, 18)
statusLabel.Position = UDim2.new(0, 10, 1, -26)
statusLabel.BackgroundTransparency = 1
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 14
statusLabel.TextColor3 = Color3.fromRGB(180,180,180)
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Text = "Mode: Toggle | Lock: OFF"

-- toggle button (draggable)
local lockToggle = Instance.new("TextButton", screenGui)
lockToggle.Name = "LockToggleBtn"
lockToggle.Size = UDim2.new(0, 80, 0, 40)
lockToggle.Position = UDim2.new(0.5, 163, 0.850000024, -339)
lockToggle.AnchorPoint = Vector2.new(0.5, 0)
lockToggle.BackgroundColor3 = Color3.fromRGB(60,60,60)
lockToggle.TextColor3 = Color3.fromRGB(255,255,255)
lockToggle.Font = Enum.Font.GothamBold
lockToggle.TextSize = 16
lockToggle.Text = "🔒 OFF"
lockToggle.Active = true

-- helpers (no wall-check anywhere)

local function getNearestPlayer()
    local closest, dist = nil, math.huge
    local myChar = LocalPlayer.Character
    if not myChar then return nil end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") and pl.Character:FindFirstChild("Humanoid") and pl.Character.Humanoid.Health > 0 then
            local mag = (myHRP.Position - pl.Character.HumanoidRootPart.Position).Magnitude
            if mag < dist then
                dist = mag
                closest = pl
            end
        end
    end
    return closest
end

local function clearHighlight()
    if HighlightHandle then
        pcall(function() HighlightHandle:Destroy() end)
        HighlightHandle = nil
    end
end

local function applyHighlightToCharacter(char)
    clearHighlight()
    if not char then return end
    local HL = Instance.new("Highlight")
    HL.Adornee = char
    HL.FillColor = Color3.fromRGB(255,40,40)
    HL.OutlineColor = Color3.fromRGB(255,255,255)
    HL.FillTransparency = 0.25
    HL.OutlineTransparency = 0
    HL.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    HL.Parent = game:GetService("CoreGui")
    HighlightHandle = HL
end

local function rotateTowards(pos)
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local dir = (Vector3.new(pos.X, hrp.Position.Y, pos.Z) - hrp.Position)
    if dir.Magnitude > 0 then
        hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + dir.Unit)
    end
end

-- NEW: smooth switch (used only by Smooth CamLock)
local function smoothSwitchTo(player)
    if not player or not player.Character then return end
    local targetPart = (aimHeadEnabled and player.Character:FindFirstChild("Head")) or player.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    smoothSwitching = true
    local duration = 0.85
    local elapsed = 0
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")

    -- temporarily disable snap so we control the transition
    local prevCamLock = camLockEnabled
    camLockEnabled = false

    while elapsed < duration do
        if LockedTarget ~= player then break end
        local dt = RunService.RenderStepped:Wait()
        elapsed += dt

        if not hrp or not hrp.Parent then
            char = LocalPlayer.Character
            hrp = char and char:FindFirstChild("HumanoidRootPart")
        end

        local tpos = targetPart.Position
        -- smooth character turn
        if hrp then
            local lookDir = (Vector3.new(tpos.X, hrp.Position.Y, tpos.Z) - hrp.Position).Unit
            local desired = CFrame.new(hrp.Position, hrp.Position + lookDir)
            hrp.CFrame = hrp.CFrame:Lerp(desired, math.clamp(CAM_SMOOTHNESS * dt, 0, 1))
        end
        -- smooth camera turn
        local camPos = Camera.CFrame.Position
        local camDesired = CFrame.new(camPos, tpos)
        Camera.CFrame = Camera.CFrame:Lerp(camDesired, math.clamp(CAM_SMOOTHNESS * dt, 0, 1))
    end

    -- finalize: resume CamLock snap after the smooth switch
    if LockedTarget == player then
        local t = (aimHeadEnabled and player.Character:FindFirstChild("Head")) or player.Character:FindFirstChild("HumanoidRootPart")
        if t then
            if hrp then
                local lookDir = (Vector3.new(t.Position.X, hrp.Position.Y, t.Position.Z) - hrp.Position).Unit
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDir)
            end
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, t.Position)
        end
    end

    camLockEnabled = true -- force CamLock to stay ON after smooth switch
    smoothSwitching = false
end

-- main loop (dt used for smoothing)
RunService.RenderStepped:Connect(function(dt)
    if not Locking then return end

    local validTarget = LockedTarget and LockedTarget.Character and LockedTarget.Character:FindFirstChild("Humanoid") and LockedTarget.Character.Humanoid.Health > 0

    if mode == "Always" or mode == "AlwaysCam" or mode == "AlwaysSmooth" or mode == "SmoothCam" then
        local nearest = getNearestPlayer()
        if nearest ~= LockedTarget then
            LockedTarget = nearest
            if LockedTarget then
                applyHighlightToCharacter(LockedTarget.Character)
                if mode == "SmoothCam" then
                    smoothSwitchTo(LockedTarget) -- smooth only on switch in this mode
                end
            else
                clearHighlight()
            end
        end
    elseif mode == "Toggle" or mode == "ToggleCam" then
        if not validTarget then
            LockedTarget = getNearestPlayer()
            if LockedTarget then applyHighlightToCharacter(LockedTarget.Character) else clearHighlight() end
        end
    end

    if LockedTarget and LockedTarget.Character then
        -- during smooth switch, let the smoother drive orientation
        if smoothSwitching then
            statusLabel.Text = ("Mode: %s | Lock: Switching -> %s"):format(mode, LockedTarget.Name or "Unknown")
            return
        end

        -- choose target part based on AimHead toggle
        local targetPart = LockedTarget.Character:FindFirstChild("HumanoidRootPart")
        if aimHeadEnabled and LockedTarget.Character:FindFirstChild("Head") then
            targetPart = LockedTarget.Character:FindFirstChild("Head")
        end

        if targetPart then
            local targetPos = targetPart.Position
            rotateTowards(targetPos)

            -- SMOOTH CAMERA BEHAVIOR (for AlwaysSmooth only)
            if camSmoothMode then
                local camPos = Camera.CFrame.Position
                local desired = CFrame.new(camPos, targetPos)
                local alpha = math.clamp(CAM_SMOOTHNESS * dt, 0, 1)
                Camera.CFrame = Camera.CFrame:Lerp(desired, alpha)
            elseif camLockEnabled then
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPos)
            end

            statusLabel.Text = ("Mode: %s | Lock: ON -> %s"):format(mode, LockedTarget.Name or "Unknown")
        end
    else
        statusLabel.Text = ("Mode: %s | Lock: ON (no target)"):format(mode)
    end
end)

-- lock toggle
local function setLocking(on)
    Locking = on
    if not on then
        LockedTarget = nil
        clearHighlight()
        lockToggle.Text = "🔒 OFF"
        lockToggle.BackgroundColor3 = Color3.fromRGB(60,60,60)
        statusLabel.Text = ("Mode: %s | Lock: OFF"):format(mode)

        local cam = workspace.CurrentCamera
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            cam.CameraSubject = hum
            cam.CameraType = Enum.CameraType.Custom
        end
    else
        LockedTarget = getNearestPlayer()
        if LockedTarget then applyHighlightToCharacter(LockedTarget.Character) end
        lockToggle.Text = "🔒 ON"
        lockToggle.BackgroundColor3 = Color3.fromRGB(160,30,30)
    end
end

-- mode handlers
local function setMode(m)
    mode = m
    camLockEnabled = (m == "AlwaysCam" or m == "ToggleCam" or m == "SmoothCam")
    camSmoothMode = (m == "AlwaysSmooth" or m == "ToggleSmooth") -- unchanged

    alwaysBtn.BackgroundColor3     = (m == "Always")       and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    toggleBtn.BackgroundColor3     = (m == "Toggle")       and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    alwaysCamBtn.BackgroundColor3  = (m == "AlwaysCam")    and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    toggleCamBtn.BackgroundColor3  = (m == "ToggleCam")    and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    alwaysSmoothBtn.BackgroundColor3 = (m == "AlwaysSmooth") and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    smoothCamBtn.BackgroundColor3  = (m == "SmoothCam")    and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)

    if AUTO_START_AFTER_MODE_CLICK then
        task.delay(MODE_CLICK_DELAY, function()
            setLocking(true)
        end)
    end
end

-- connect buttons
alwaysBtn.MouseButton1Click:Connect(function() setMode("Always") end)
toggleBtn.MouseButton1Click:Connect(function() setMode("Toggle") end)
alwaysCamBtn.MouseButton1Click:Connect(function() setMode("AlwaysCam") end)
toggleCamBtn.MouseButton1Click:Connect(function() setMode("ToggleCam") end)
alwaysSmoothBtn.MouseButton1Click:Connect(function() setMode("AlwaysSmooth") end)
smoothCamBtn.MouseButton1Click:Connect(function() setMode("SmoothCam") end)
lockToggle.MouseButton1Click:Connect(function() setLocking(not Locking) end)

-- AimHead button toggle (unchanged)
aimHeadBtn.MouseButton1Click:Connect(function()
    aimHeadEnabled = not aimHeadEnabled
    aimHeadBtn.Text = "AimHead: " .. (aimHeadEnabled and "ON" or "OFF")
    aimHeadBtn.BackgroundColor3 = aimHeadEnabled and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
end)

-- cleanup
Players.PlayerRemoving:Connect(function(p) if LockedTarget == p then LockedTarget = nil clearHighlight() end end)
LocalPlayer.CharacterRemoving:Connect(function() clearHighlight() LockedTarget = nil end)

-- toggle show/hide panel
local pickLockToggle = Instance.new("TextButton", screenGui)
pickLockToggle.Name = "PickLockToggleBtn"
pickLockToggle.Size = UDim2.new(0, 40, 0, 40)
pickLockToggle.Position = UDim2.new(1, -60, 0.358799934, 0)
pickLockToggle.BackgroundColor3 = Color3.fromRGB(50,50,50)
pickLockToggle.Text = "⚙️"
pickLockToggle.Font = Enum.Font.GothamBold
pickLockToggle.TextSize = 20
pickLockToggle.TextColor3 = Color3.fromRGB(255,255,255)

local panelVisible = true
pickLockToggle.MouseButton1Click:Connect(function()
    panelVisible = not panelVisible
    panel.Visible = panelVisible
end)panel.BorderSizePixel = 0
panel.Active = true
local panelCorner = Instance.new("UICorner", panel)
panelCorner.CornerRadius = UDim.new(0, 14)

local title = Instance.new("TextLabel", panel)
title.Size = UDim2.new(1, -20, 0, 36)
title.Position = UDim2.new(0, 10, 0, 10)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(230,230,230)
title.TextXAlignment = Enum.TextXAlignment.Left
title.Text = "Which Lock Do You Want?"

local buttonsFrame = Instance.new("Frame", panel)
buttonsFrame.Size = UDim2.new(1, -20, 0, 250) -- ENLARGED height to allow one more row
buttonsFrame.Position = UDim2.new(0, 10, 0, 54)
buttonsFrame.BackgroundTransparency = 1

local function makeModeButton(parent, xOffset, yOffset, text)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(0, 230, 0, 40)
    btn.Position = UDim2.new(0, xOffset, 0, yOffset)
    btn.Text = text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 16
    btn.TextColor3 = Color3.fromRGB(240,240,240)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,50)
    btn.BorderSizePixel = 0
    return btn
end

-- original 2 buttons
local alwaysBtn = makeModeButton(buttonsFrame, 0, 0, "Always Nearest")
local toggleBtn = makeModeButton(buttonsFrame, 240, 0, "Toggle Nearest")

-- camlock buttons
local alwaysCamBtn = makeModeButton(buttonsFrame, 0, 50, "Always CamLock")
local toggleCamBtn = makeModeButton(buttonsFrame, 240, 50, "Toggle CamLock")

-- Always Smooth button
local alwaysSmoothBtn = makeModeButton(buttonsFrame, 0, 100, "Always Smooth")

-- AimHead toggle button
local aimHeadBtn = makeModeButton(buttonsFrame, 240, 100, "AimHead: OFF")

-- NEW: Smooth CamLock button (new 4th row)
local smoothCamBtn = makeModeButton(buttonsFrame, 0, 150, "Smooth CamLock")

local statusLabel = Instance.new("TextLabel", panel)
statusLabel.Size = UDim2.new(1, -20, 0, 18)
statusLabel.Position = UDim2.new(0, 10, 1, -26)
statusLabel.BackgroundTransparency = 1
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 14
statusLabel.TextColor3 = Color3.fromRGB(180,180,180)
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Text = "Mode: Toggle | Lock: OFF"

-- toggle button (draggable)
local lockToggle = Instance.new("TextButton", screenGui)
lockToggle.Name = "LockToggleBtn"
lockToggle.Size = UDim2.new(0, 80, 0, 40)
lockToggle.Position = UDim2.new(0.5, 163, 0.850000024, -339)
lockToggle.AnchorPoint = Vector2.new(0.5, 0)
lockToggle.BackgroundColor3 = Color3.fromRGB(60,60,60)
lockToggle.TextColor3 = Color3.fromRGB(255,255,255)
lockToggle.Font = Enum.Font.GothamBold
lockToggle.TextSize = 16
lockToggle.Text = "🔒 OFF"
lockToggle.Active = true

-- helpers (no wall-check anywhere)

local function getNearestPlayer()
    local closest, dist = nil, math.huge
    local myChar = LocalPlayer.Character
    if not myChar then return nil end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") and pl.Character:FindFirstChild("Humanoid") and pl.Character.Humanoid.Health > 0 then
            local mag = (myHRP.Position - pl.Character.HumanoidRootPart.Position).Magnitude
            if mag < dist then
                dist = mag
                closest = pl
            end
        end
    end
    return closest
end

local function clearHighlight()
    if HighlightHandle then
        pcall(function() HighlightHandle:Destroy() end)
        HighlightHandle = nil
    end
end

local function applyHighlightToCharacter(char)
    clearHighlight()
    if not char then return end
    local HL = Instance.new("Highlight")
    HL.Adornee = char
    HL.FillColor = Color3.fromRGB(255,40,40)
    HL.OutlineColor = Color3.fromRGB(255,255,255)
    HL.FillTransparency = 0.25
    HL.OutlineTransparency = 0
    HL.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    HL.Parent = game:GetService("CoreGui")
    HighlightHandle = HL
end

local function rotateTowards(pos)
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local dir = (Vector3.new(pos.X, hrp.Position.Y, pos.Z) - hrp.Position)
    if dir.Magnitude > 0 then
        hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + dir.Unit)
    end
end

-- NEW: smooth switch (used only by Smooth CamLock)
local function smoothSwitchTo(player)
    if not player or not player.Character then return end
    local targetPart = (aimHeadEnabled and player.Character:FindFirstChild("Head")) or player.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    smoothSwitching = true
    local duration = 0.85
    local elapsed = 0
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")

    -- temporarily disable snap so we control the transition
    local prevCamLock = camLockEnabled
    camLockEnabled = false

    while elapsed < duration do
        if LockedTarget ~= player then break end
        local dt = RunService.RenderStepped:Wait()
        elapsed += dt

        if not hrp or not hrp.Parent then
            char = LocalPlayer.Character
            hrp = char and char:FindFirstChild("HumanoidRootPart")
        end

        local tpos = targetPart.Position
        -- smooth character turn
        if hrp then
            local lookDir = (Vector3.new(tpos.X, hrp.Position.Y, tpos.Z) - hrp.Position).Unit
            local desired = CFrame.new(hrp.Position, hrp.Position + lookDir)
            hrp.CFrame = hrp.CFrame:Lerp(desired, math.clamp(CAM_SMOOTHNESS * dt, 0, 1))
        end
        -- smooth camera turn
        local camPos = Camera.CFrame.Position
        local camDesired = CFrame.new(camPos, tpos)
        Camera.CFrame = Camera.CFrame:Lerp(camDesired, math.clamp(CAM_SMOOTHNESS * dt, 0, 1))
    end

    -- finalize: resume CamLock snap after the smooth switch
    if LockedTarget == player then
        local t = (aimHeadEnabled and player.Character:FindFirstChild("Head")) or player.Character:FindFirstChild("HumanoidRootPart")
        if t then
            if hrp then
                local lookDir = (Vector3.new(t.Position.X, hrp.Position.Y, t.Position.Z) - hrp.Position).Unit
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDir)
            end
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, t.Position)
        end
    end

    camLockEnabled = true -- force CamLock to stay ON after smooth switch
    smoothSwitching = false
end

-- main loop (dt used for smoothing)
RunService.RenderStepped:Connect(function(dt)
    if not Locking then return end

    local validTarget = LockedTarget and LockedTarget.Character and LockedTarget.Character:FindFirstChild("Humanoid") and LockedTarget.Character.Humanoid.Health > 0

    if mode == "Always" or mode == "AlwaysCam" or mode == "AlwaysSmooth" or mode == "SmoothCam" then
        local nearest = getNearestPlayer()
        if nearest ~= LockedTarget then
            LockedTarget = nearest
            if LockedTarget then
                applyHighlightToCharacter(LockedTarget.Character)
                if mode == "SmoothCam" then
                    smoothSwitchTo(LockedTarget) -- smooth only on switch in this mode
                end
            else
                clearHighlight()
            end
        end
    elseif mode == "Toggle" or mode == "ToggleCam" then
        if not validTarget then
            LockedTarget = getNearestPlayer()
            if LockedTarget then applyHighlightToCharacter(LockedTarget.Character) else clearHighlight() end
        end
    end

    if LockedTarget and LockedTarget.Character then
        -- during smooth switch, let the smoother drive orientation
        if smoothSwitching then
            statusLabel.Text = ("Mode: %s | Lock: Switching -> %s"):format(mode, LockedTarget.Name or "Unknown")
            return
        end

        -- choose target part based on AimHead toggle
        local targetPart = LockedTarget.Character:FindFirstChild("HumanoidRootPart")
        if aimHeadEnabled and LockedTarget.Character:FindFirstChild("Head") then
            targetPart = LockedTarget.Character:FindFirstChild("Head")
        end

        if targetPart then
            local targetPos = targetPart.Position
            rotateTowards(targetPos)

            -- SMOOTH CAMERA BEHAVIOR (for AlwaysSmooth only)
            if camSmoothMode then
                local camPos = Camera.CFrame.Position
                local desired = CFrame.new(camPos, targetPos)
                local alpha = math.clamp(CAM_SMOOTHNESS * dt, 0, 1)
                Camera.CFrame = Camera.CFrame:Lerp(desired, alpha)
            elseif camLockEnabled then
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPos)
            end

            statusLabel.Text = ("Mode: %s | Lock: ON -> %s"):format(mode, LockedTarget.Name or "Unknown")
        end
    else
        statusLabel.Text = ("Mode: %s | Lock: ON (no target)"):format(mode)
    end
end)

-- lock toggle
local function setLocking(on)
    Locking = on
    if not on then
        LockedTarget = nil
        clearHighlight()
        lockToggle.Text = "🔒 OFF"
        lockToggle.BackgroundColor3 = Color3.fromRGB(60,60,60)
        statusLabel.Text = ("Mode: %s | Lock: OFF"):format(mode)

        local cam = workspace.CurrentCamera
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            cam.CameraSubject = hum
            cam.CameraType = Enum.CameraType.Custom
        end
    else
        LockedTarget = getNearestPlayer()
        if LockedTarget then applyHighlightToCharacter(LockedTarget.Character) end
        lockToggle.Text = "🔒 ON"
        lockToggle.BackgroundColor3 = Color3.fromRGB(160,30,30)
    end
end

-- mode handlers
local function setMode(m)
    mode = m
    camLockEnabled = (m == "AlwaysCam" or m == "ToggleCam" or m == "SmoothCam")
    camSmoothMode = (m == "AlwaysSmooth" or m == "ToggleSmooth") -- unchanged

    alwaysBtn.BackgroundColor3     = (m == "Always")       and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    toggleBtn.BackgroundColor3     = (m == "Toggle")       and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    alwaysCamBtn.BackgroundColor3  = (m == "AlwaysCam")    and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    toggleCamBtn.BackgroundColor3  = (m == "ToggleCam")    and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    alwaysSmoothBtn.BackgroundColor3 = (m == "AlwaysSmooth") and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
    smoothCamBtn.BackgroundColor3  = (m == "SmoothCam")    and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)

    if AUTO_START_AFTER_MODE_CLICK then
        task.delay(MODE_CLICK_DELAY, function()
            setLocking(true)
        end)
    end
end

-- connect buttons
alwaysBtn.MouseButton1Click:Connect(function() setMode("Always") end)
toggleBtn.MouseButton1Click:Connect(function() setMode("Toggle") end)
alwaysCamBtn.MouseButton1Click:Connect(function() setMode("AlwaysCam") end)
toggleCamBtn.MouseButton1Click:Connect(function() setMode("ToggleCam") end)
alwaysSmoothBtn.MouseButton1Click:Connect(function() setMode("AlwaysSmooth") end)
smoothCamBtn.MouseButton1Click:Connect(function() setMode("SmoothCam") end)
lockToggle.MouseButton1Click:Connect(function() setLocking(not Locking) end)

-- AimHead button toggle (unchanged)
aimHeadBtn.MouseButton1Click:Connect(function()
    aimHeadEnabled = not aimHeadEnabled
    aimHeadBtn.Text = "AimHead: " .. (aimHeadEnabled and "ON" or "OFF")
    aimHeadBtn.BackgroundColor3 = aimHeadEnabled and Color3.fromRGB(70,70,80) or Color3.fromRGB(40,40,50)
end)

-- cleanup
Players.PlayerRemoving:Connect(function(p) if LockedTarget == p then LockedTarget = nil clearHighlight() end end)
LocalPlayer.CharacterRemoving:Connect(function() clearHighlight() LockedTarget = nil end)

-- toggle show/hide panel
local pickLockToggle = Instance.new("TextButton", screenGui)
pickLockToggle.Name = "PickLockToggleBtn"
pickLockToggle.Size = UDim2.new(0, 40, 0, 40)
pickLockToggle.Position = UDim2.new(1, -60, 0.358799934, 0)
pickLockToggle.BackgroundColor3 = Color3.fromRGB(50,50,50)
pickLockToggle.Text = "⚙️"
pickLockToggle.Font = Enum.Font.GothamBold
pickLockToggle.TextSize = 20
pickLockToggle.TextColor3 = Color3.fromRGB(255,255,255)

local panelVisible = true
pickLockToggle.MouseButton1Click:Connect(function()
    panelVisible = not panelVisible
    panel.Visible = panelVisible
end)
























wait(10.67)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Function to create UI elements quickly
local function create(className, props)
    local obj = Instance.new(className)
    for k,v in pairs(props or {}) do
        obj[k] = v
    end
    return obj
end

-- Create the main ScreenGui
local screenGui = create("ScreenGui", {
    Name = "FeatureToggleGui",
    Parent = PlayerGui,
    ResetOnSpawn = false,
    ZIndexBehavior = Enum.ZIndexBehavior.Global
})

-- Create a semi-transparent dark background
local background = create("Frame", {
    Parent = screenGui,
    BackgroundColor3 = Color3.fromRGB(25, 25, 25),
    BackgroundTransparency = 0.15,
    Size = UDim2.new(1, 0, 1, 0),
})

-- Center frame for the popup window
local popup = create("Frame", {
    Parent = background,
    Size = UDim2.new(0, 350, 0, 250),
    Position = UDim2.new(0.5, 0, 0.5, 0),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = Color3.fromRGB(40, 40, 40),
    ClipsDescendants = true,
})
-- Rounded corners
local corner = create("UICorner", {
    Parent = popup,
    CornerRadius = UDim.new(0, 15)
})

-- Title text
local title = create("TextLabel", {
    Parent = popup,
    Size = UDim2.new(1, -40, 0, 50),
    Position = UDim2.new(0, 20, 0, 20),
    BackgroundTransparency = 1,
    Text = "Do you want to enable the following features?",
    Font = Enum.Font.Roboto,
    TextSize = 20,
    TextColor3 = Color3.fromRGB(230, 230, 230),
    TextWrapped = true,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextYAlignment = Enum.TextYAlignment.Center,
})

-- Feature list container
local featuresFrame = create("Frame", {
    Parent = popup,
    Size = UDim2.new(1, -40, 0, 110),
    Position = UDim2.new(0, 20, 0, 80),
    BackgroundTransparency = 1,
})

local features = {"Anti Lag", "Full Bright", "No Fog", "No Global Shadows"}

for i, feature in ipairs(features) do
    local featureText = create("TextLabel", {
        Parent = featuresFrame,
        Size = UDim2.new(1, 0, 0, 1),
        Position = UDim2.new(0, 0, 0, (i-1)*28),
        BackgroundTransparency = 1,
        Text = "â€¢ "..feature,
        Font = Enum.Font.Roboto,
        TextSize = 16,
        TextColor3 = Color3.fromRGB(200, 200, 200),
        TextXAlignment = Enum.TextXAlignment.Left,
        TextYAlignment = Enum.TextYAlignment.Center,
    })
end

-- Buttons container
local buttonsFrame = create("Frame", {
    Parent = popup,
    Size = UDim2.new(1, -40, 0, 50),
    Position = UDim2.new(0, 20, 1, -70),
    BackgroundTransparency = 1,
})

-- Helper to create buttons
local function createButton(text, position)
    local btn = create("TextButton", {
        Parent = buttonsFrame,
        Size = UDim2.new(0.45, 0, 1, 0),
        Position = position,
        BackgroundColor3 = Color3.fromRGB(70, 70, 70),
        Text = text,
        Font = Enum.Font.Roboto,
        TextSize = 20,
        TextColor3 = Color3.fromRGB(230, 230, 230),
        AutoButtonColor = false,
        ClipsDescendants = true,
    })
    create("UICorner", {Parent = btn, CornerRadius = UDim.new(0, 12)})
    return btn
end

local yesButton = createButton("Yes", UDim2.new(0, 0, 0, 0))
local noButton = createButton("No", UDim2.new(0.55, 0, 0, 0))

-- Hover effects for buttons
for _, btn in pairs({yesButton, noButton}) do
    btn.MouseEnter:Connect(function()
        btn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end)
    btn.MouseLeave:Connect(function()
        btn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    end)
end

-- The function to enable all features (the combined script from before)
local function enableFeatures()
    -- Terrain water setup
    local Terrain = Workspace:FindFirstChildOfClass("Terrain")
    if Terrain then
        Terrain.WaterWaveSize = 0
        Terrain.WaterWaveSpeed = 0
        Terrain.WaterReflectance = 0
        Terrain.WaterTransparency = 1
    end

    Lighting.GlobalShadows = false
    Lighting.FogStart = 9e9
    Lighting.FogEnd = 9e9
    Lighting.Brightness = 2
    Lighting.ClockTime = 14
    Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)

    settings().Rendering.QualityLevel = 1

-- Remove Atmosphere and disable PostEffects
for _, v in pairs(Lighting:GetDescendants()) do
    if v:IsA("Atmosphere") then
        v:Destroy()
    elseif v:IsA("PostEffect") then
        v.Enabled = false
    end
end

-- Loop No Fog
task.spawn(function()
    while true do
        Lighting.FogStart = 9e9
        Lighting.FogEnd = 9e9
        wait(1)
    end
end)

-- Optimize parts, decals, particles, and trails
for _, v in pairs(game:GetDescendants()) do
    if v:IsA("BasePart") then
        v.Material = Enum.Material.Plastic
        v.Reflectance = 0
        v.BackSurface = Enum.SurfaceType.SmoothNoOutlines
        v.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
        v.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
        v.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
        v.RightSurface = Enum.SurfaceType.SmoothNoOutlines
        v.TopSurface = Enum.SurfaceType.SmoothNoOutlines
    elseif v:IsA("Decal") then
        v.Transparency = 1
    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
        v.Lifetime = NumberRange.new(0)
    end
end


    -- Remove effects on spawn for antlag
    Workspace.DescendantAdded:Connect(function(child)
        if child:IsA("ForceField") or child:IsA("Sparkles") or child:IsA("Smoke") or child:IsA("Fire") or child:IsA("Beam") then
            RunService.Heartbeat:Wait()
            if child and child.Parent then
                child:Destroy()
            end
        end
    end)

    -- Keep lighting bright every frame
    local brightLoop
    if brightLoop then brightLoop:Disconnect() end
    brightLoop = RunService.RenderStepped:Connect(function()
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 9e9
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    end)
end

-- Yes button click
yesButton.MouseButton1Click:Connect(function()
    enableFeatures()
    screenGui:Destroy()
end)

-- No button click
noButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)



















wait(6.7)
_G.HeadSize = Vector3.new(3, 4, 3) -- fixed head hitbox size
_G.HumanoidRootPartSize = Vector3.new(0.5, 2.5, 1) -- HRP small
_G.Disabled = false

local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local LocalPlayer = Players.LocalPlayer

-- Force resize for a single character
local function scaleHitbox(character)
    if not character then return end
    
    local head = character:FindFirstChild("Head")
    local hrp = character:FindFirstChild("HumanoidRootPart")

    if head then
        head.Size = _G.HeadSize
        head.CanCollide = false
        local mesh = head:FindFirstChildOfClass("SpecialMesh")
        if mesh then
            mesh.Scale = Vector3.new(
                _G.HeadSize.X / head.Size.X,
                _G.HeadSize.Y / head.Size.Y,
                _G.HeadSize.Z / head.Size.Z
            )
        else
            local newMesh = Instance.new("SpecialMesh")
            newMesh.Scale = Vector3.new(
                _G.HeadSize.X / head.Size.X,
                _G.HeadSize.Y / head.Size.Y,
                _G.HeadSize.Z / head.Size.Z
            )
            newMesh.Parent = head
        end
    end

    if hrp then
        hrp.Size = _G.HumanoidRootPartSize
        hrp.Transparency = 0.7
        hrp.BrickColor = BrickColor.new("Really blue")
        hrp.Material = "Neon"
        hrp.CanCollide = false
    end
end

-- Apply to character, and also whenever new parts get added
local function setupCharacter(character)
    if not character then return end
    scaleHitbox(character)

    -- Watch for new Head or HRP appearing (covers respawns & R15/R6 changes)
    character.ChildAdded:Connect(function(child)
        if child.Name == "Head" or child.Name == "HumanoidRootPart" then
            scaleHitbox(character)
        end
    end)
end

-- Handle respawns properly
local function onPlayerAdded(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid")
            setupCharacter(char)
        end)

        if player.Character then
            setupCharacter(player.Character)
        end
    end
end

-- Apply for current players
for _, player in ipairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)

-- Constantly enforce size so nobody "escapes" scaling
RunService.RenderStepped:Connect(function()
    if not _G.Disabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                scaleHitbox(player.Character)
            end
        end
    end
end)

-- Disable collision for local player parts
local function disableCollision(character)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

LocalPlayer.CharacterAdded:Connect(disableCollision)
if LocalPlayer.Character then
    disableCollision(LocalPlayer.Character)
end
