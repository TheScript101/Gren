-- Model Builder (executor-friendly; voxelized; fast; cancelable)
-- Paste into your executor. Uses game:GetObjects("rbxassetid://ID").

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local AddObjectRemote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("AddObject")

-- Config
local BLOCK_SIZE = Vector3.new(4, 1, 2)        -- fixed remote spawn block size
local CONCURRENCY = 80                         -- how many remote calls at once; lower if rate-limited
local INVOKE_DELAY = 0                         -- extra delay between batches (0 = as fast as possible)
local EPSILON = 0.01                           -- tolerance for point-in-part test

-- State
local cancelBuild = false

-- ---------- UI ----------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FastModelBuilder"
screenGui.ResetOnSpawn = false
screenGui.Parent = game.CoreGui

local frame = Instance.new("Frame", screenGui)
frame.Size = UDim2.new(0, 360, 0, 170)
frame.Position = UDim2.new(0.5, -180, 0.5, -85)
frame.BackgroundColor3 = Color3.fromRGB(28, 28, 30)
frame.BorderSizePixel = 0
frame.Visible = true

local corner = Instance.new("UICorner", frame)
corner.CornerRadius = UDim.new(0,8)

local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, -20, 0, 28)
title.Position = UDim2.new(0, 10, 0, 8)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.TextColor3 = Color3.fromRGB(235,235,235)
title.Text = "Fast Model Builder"

local idBox = Instance.new("TextBox", frame)
idBox.Size = UDim2.new(1, -20, 0, 30)
idBox.Position = UDim2.new(0, 10, 0, 42)
idBox.PlaceholderText = "Enter model ID (numbers only)"
idBox.ClearTextOnFocus = false
idBox.Text = ""

local buildBtn = Instance.new("TextButton", frame)
buildBtn.Size = UDim2.new(0.48, -10, 0, 34)
buildBtn.Position = UDim2.new(0, 10, 0, 80)
buildBtn.Text = "Build"
buildBtn.Font = Enum.Font.GothamBold
buildBtn.TextSize = 15
buildBtn.BackgroundColor3 = Color3.fromRGB(60,160,70)
buildBtn.TextColor3 = Color3.fromRGB(255,255,255)

local cancelBtn = Instance.new("TextButton", frame)
cancelBtn.Size = UDim2.new(0.48, -10, 0, 34)
cancelBtn.Position = UDim2.new(0.52, 0, 0, 80)
cancelBtn.Text = "Cancel"
cancelBtn.Font = Enum.Font.GothamBold
cancelBtn.TextSize = 15
cancelBtn.BackgroundColor3 = Color3.fromRGB(180,60,60)
cancelBtn.TextColor3 = Color3.fromRGB(255,255,255)

local progLabel = Instance.new("TextLabel", frame)
progLabel.Size = UDim2.new(1, -20, 0, 20)
progLabel.Position = UDim2.new(0, 10, 0, 124)
progLabel.BackgroundTransparency = 1
progLabel.Font = Enum.Font.Gotham
progLabel.TextSize = 13
progLabel.TextColor3 = Color3.fromRGB(200,200,200)
progLabel.Text = "Idle"

local toggleGuiBtn = Instance.new("TextButton", screenGui)
toggleGuiBtn.Size = UDim2.new(0, 38, 0, 38)
toggleGuiBtn.Position = UDim2.new(1, -60, 0.35, 0)
toggleGuiBtn.Text = "⚙️"
toggleGuiBtn.Font = Enum.Font.Gotham
toggleGuiBtn.TextSize = 20
toggleGuiBtn.BackgroundColor3 = Color3.fromRGB(45,45,45)
toggleGuiBtn.TextColor3 = Color3.fromRGB(255,255,255)
toggleGuiBtn.Name = "ToggleBuilder"

toggleGuiBtn.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
end)

cancelBtn.MouseButton1Click:Connect(function()
    cancelBuild = true
end)

-- ---------- Helpers ----------
local function snapToGrid(pos)
    return Vector3.new(
        math.floor(pos.X / BLOCK_SIZE.X + 0.5) * BLOCK_SIZE.X,
        math.floor(pos.Y / BLOCK_SIZE.Y + 0.5) * BLOCK_SIZE.Y,
        math.floor(pos.Z / BLOCK_SIZE.Z + 0.5) * BLOCK_SIZE.Z
    )
end

local function makeKey(v)
    -- string key for dedupe
    return string.format("%.3f,%.3f,%.3f", v.X, v.Y, v.Z)
end

-- Check whether a world-space point lies inside (or on) a part (accounts for rotation)
local function pointInsidePart(part, worldPoint)
    local ok, localP = pcall(function() return part.CFrame:PointToObjectSpace(worldPoint) end)
    if not ok or not localP then return false end
    local sx, sy, sz = part.Size.X/2 + EPSILON, part.Size.Y/2 + EPSILON, part.Size.Z/2 + EPSILON
    return math.abs(localP.X) <= sx and math.abs(localP.Y) <= sy and math.abs(localP.Z) <= sz
end

-- Compute axis-aligned world AABB corners for a part (returns minVec, maxVec)
local function partWorldAABB(part)
    local hx, hy, hz = part.Size.X/2, part.Size.Y/2, part.Size.Z/2
    local corners = {
        Vector3.new( hx,  hy,  hz),
        Vector3.new( hx,  hy, -hz),
        Vector3.new( hx, -hy,  hz),
        Vector3.new( hx, -hy, -hz),
        Vector3.new(-hx,  hy,  hz),
        Vector3.new(-hx,  hy, -hz),
        Vector3.new(-hx, -hy,  hz),
        Vector3.new(-hx, -hy, -hz),
    }
    local minx, miny, minz = math.huge, math.huge, math.huge
    local maxx, maxy, maxz = -math.huge, -math.huge, -math.huge
    for _, c in ipairs(corners) do
        local world = part.CFrame:PointToWorldSpace(c)
        minx = math.min(minx, world.X); miny = math.min(miny, world.Y); minz = math.min(minz, world.Z)
        maxx = math.max(maxx, world.X); maxy = math.max(maxy, world.Y); maxz = math.max(maxz, world.Z)
    end
    return Vector3.new(minx, miny, minz), Vector3.new(maxx, maxy, maxz)
end

-- Determine remote call method and wrapper (fast path uses FireServer if RemoteEvent)
local isRemoteEvent = AddObjectRemote.ClassName == "RemoteEvent"
local function safeFire(args)
    if isRemoteEvent then
        -- FireServer is non-blocking
        local ok, err = pcall(function() AddObjectRemote:FireServer(unpack(args)) end)
        return ok, err
    else
        -- RemoteFunction: call via task.spawn (so it doesn't block main thread)
        local co = coroutine.create(function()
            pcall(function() AddObjectRemote:InvokeServer(unpack(args)) end)
        end)
        local ok, err = coroutine.resume(co)
        return ok, err
    end
end

-- ---------- Voxelization & Build ----------
local function buildModelFromAsset(assetId)
    cancelBuild = false
    progLabel.Text = "Loading asset..."
    local success, arr = pcall(function()
        return game:GetObjects("rbxassetid://" .. tostring(assetId))
    end)
    if not success or not arr or #arr == 0 then
        progLabel.Text = "Failed to load asset."
        return
    end
    local model = arr[1]

    -- Ensure we have a PrimaryPart
    if not model.PrimaryPart then
        for _, v in ipairs(model:GetDescendants()) do
            if v:IsA("BasePart") then
                model.PrimaryPart = v
                break
            end
        end
        if not model.PrimaryPart then
            progLabel.Text = "Model has no parts."
            model:Destroy()
            return
        end
    end

    -- Compute player's origin (where model.PrimaryPart will map to)
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local origin = hrp.Position

    -- Offset to apply to every sample so model.PrimaryPart ends up at origin
    local offset = origin - model.PrimaryPart.Position

    -- Collect all candidate voxel centers (world-space, based on model's position)
    progLabel.Text = "Voxelizing..."
    local voxelSet = {}
    local totalParts = 0
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            totalParts = totalParts + 1
            local aabbMin, aabbMax = partWorldAABB(part)
            -- expand bounds slightly to avoid missed edge voxels
            aabbMin = aabbMin - Vector3.new(BLOCK_SIZE.X, BLOCK_SIZE.Y, BLOCK_SIZE.Z)
            aabbMax = aabbMax + Vector3.new(BLOCK_SIZE.X, BLOCK_SIZE.Y, BLOCK_SIZE.Z)

            local ixMin = math.floor(aabbMin.X / BLOCK_SIZE.X) - 1
            local iyMin = math.floor(aabbMin.Y / BLOCK_SIZE.Y) - 1
            local izMin = math.floor(aabbMin.Z / BLOCK_SIZE.Z) - 1
            local ixMax = math.ceil(aabbMax.X / BLOCK_SIZE.X) + 1
            local iyMax = math.ceil(aabbMax.Y / BLOCK_SIZE.Y) + 1
            local izMax = math.ceil(aabbMax.Z / BLOCK_SIZE.Z) + 1

            for ix = ixMin, ixMax do
                if cancelBuild then break end
                local x = ix * BLOCK_SIZE.X
                for iy = iyMin, iyMax do
                    local y = iy * BLOCK_SIZE.Y
                    for iz = izMin, izMax do
                        local z = iz * BLOCK_SIZE.Z
                        local center = Vector3.new(x, y, z)
                        -- quick AABB cull: skip if center not in part's AABB
                        if center.X >= aabbMin.X - 0.001 and center.X <= aabbMax.X + 0.001
                        and center.Y >= aabbMin.Y - 0.001 and center.Y <= aabbMax.Y + 0.001
                        and center.Z >= aabbMin.Z - 0.001 and center.Z <= aabbMax.Z + 0.001 then
                            if pointInsidePart(part, center) then
                                local key = makeKey(center)
                                voxelSet[key] = center  -- dedupe by center
                            end
                        end
                    end
                    if cancelBuild then break end
                end
                if cancelBuild then break end
            end
            if cancelBuild then break end
        end
    end

    if cancelBuild then
        progLabel.Text = "Canceled."
        model:Destroy()
        return
    end

    -- Convert voxel centers to final snapped centers in player-space
    progLabel.Text = "Preparing placement..."
    local finalSet = {}
    for k, center in pairs(voxelSet) do
        local targetWorld = center + offset
        local snapped = snapToGrid(targetWorld)
        finalSet[makeKey(snapped)] = snapped
    end

    -- gather sorted list (sort by proximity to player so build fills outward/inward)
    local list = {}
    local hrpPos = hrp.Position
    for k, v in pairs(finalSet) do
        table.insert(list, v)
    end
    table.sort(list, function(a,b)
        return (a - hrpPos).Magnitude < (b - hrpPos).Magnitude
    end)

    -- Build: send remote calls in parallel with concurrency cap
    progLabel.Text = ("Spawning %d blocks..."):format(#list)
    local spawned = 0
    local succeeded = 0
    local failed = 0

    local running = 0
    local idx = 1
    local total = #list

    while idx <= total and not cancelBuild do
        if running < CONCURRENCY then
            running = running + 1
            local pos = list[idx]
            idx = idx + 1

            task.spawn(function()
                local args = {
                    [1] = "Part",
                    [2] = CFrame.new(pos)
                }
                local ok, err = pcall(function() 
                    if isRemoteEvent then
                        AddObjectRemote:FireServer(unpack(args))
                    else
                        AddObjectRemote:InvokeServer(unpack(args))
                    end
                end)
                spawned = spawned + 1
                if ok then succeeded = succeeded + 1 else failed = failed + 1 end
                running = running - 1
            end)
        else
            -- small yielding so other threads can progress
            task.wait(0.01)
        end
        -- update progress label occasionally
        if spawned % 20 == 0 then
            progLabel.Text = string.format("Sent %d/%d (running %d)", math.min(spawned, total), total, running)
        end
    end

    -- wait for in-flight tasks to finish
    while running > 0 and not cancelBuild do
        progLabel.Text = string.format("Waiting... %d in-flight", running)
        task.wait(0.05)
    end

    if cancelBuild then
        progLabel.Text = ("Canceled after %d/%d"):format(spawned, total)
    else
        progLabel.Text = ("Done. Sent %d blocks (failed %d)."):format(succeeded, failed)
    end

    model:Destroy()
end

-- ---------- UI Bind ----------
buildBtn.MouseButton1Click:Connect(function()
    local id = tonumber(idBox.Text)
    if not id then
        progLabel.Text = "Invalid ID"
        return
    end
    cancelBuild = false
    progLabel.Text = "Starting..."
    task.spawn(function()
        buildModelFromAsset(id)
    end)
end)

-- Cleanup convenience: hide on reset, optional
Players.LocalPlayer.OnTeleport:Connect(function()
    screenGui:Destroy()
end)

-- End of script
