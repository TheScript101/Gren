-- Load TurtleLib
local lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/Turtle-Brand/Turtle-Lib/main/source.lua"))()
local gui = lib:Window("MM2 Summer Autofarm")

-- Services
local tweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local character = plr.Character or plr.CharacterAdded:Wait()
local humPart = character:WaitForChild("HumanoidRootPart")
local map

-- Settings
getgenv().TweenSpeed = 20
getgenv().OldPos = humPart.CFrame
getgenv().FPDH = workspace.FallenPartsDestroyHeight

gui:Slider("Tween Speed", 5, 35, getgenv().TweenSpeed, function(val)
    getgenv().TweenSpeed = val
end)

-- Teleport directly onto the coin
local function teleport(obj)
    if obj and humPart and obj:IsDescendantOf(workspace) then
        local dist = (humPart.Position - obj.Position).Magnitude
        local time = math.clamp(dist / getgenv().TweenSpeed, 0.2, 5)

        local tween = tweenService:Create(humPart, TweenInfo.new(time, Enum.EasingStyle.Linear), {
            CFrame = obj.CFrame
        })

        local humanoid = character:FindFirstChild("Humanoid")
        local cancelled = false
        local shouldFling = false

        -- Detect death during tween
        local deathConn
        if humanoid then
            deathConn = humanoid.Died:Connect(function()
                cancelled = true
                shouldFling = true
                tween:Cancel()
            end)
        end

        -- Monitor coin cap during tween
        local coinCheck = RunService.RenderStepped:Connect(function()
            if getBeachBallCount() >= 40 then
                cancelled = true
                shouldFling = true
                tween:Cancel()
            end
        end)

        tween:Play()
        tween.Completed:Wait()
        if deathConn then deathConn:Disconnect() end
        if coinCheck then coinCheck:Disconnect() end

        -- Touch the coin if still alive and tween wasn't cancelled
        if not cancelled and obj:FindFirstChild("TouchInterest") then
            firetouchinterest(humPart, obj, 0)
            firetouchinterest(humPart, obj, 1)
        end

        -- If tween was cancelled, wait for respawn (if dead), then fling
        if shouldFling then
            if not isAlive() then
                repeat
                    character = plr.Character or plr.CharacterAdded:Wait()
                    humPart = character:FindFirstChild("HumanoidRootPart")
                    task.wait()
                until isAlive()
            end

            local murderPlayer = findMurder()
            if murderPlayer then
                SkidFling(murderPlayer)
                task.wait(35) -- cooldown after fling
            end
        end
    end
end

-- Is player alive
local function isAlive()
    return character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid")
end

-- Get BeachBall coin count from GUI
local function getBeachBallCount()
    local g = plr:FindFirstChild("PlayerGui") and plr.PlayerGui:FindFirstChild("MainGUI")
        and plr.PlayerGui.MainGUI:FindFirstChild("Lobby") and plr.PlayerGui.MainGUI.Lobby:FindFirstChild("Dock")
        and plr.PlayerGui.MainGUI.Lobby.Dock:FindFirstChild("CoinBags") and plr.PlayerGui.MainGUI.Lobby.Dock.CoinBags:FindFirstChild("Container")
        and plr.PlayerGui.MainGUI.Lobby.Dock.CoinBags.Container:FindFirstChild("BeachBall") and plr.PlayerGui.MainGUI.Lobby.Dock.CoinBags.Container.BeachBall:FindFirstChild("CurrencyFrame")
        and plr.PlayerGui.MainGUI.Lobby.Dock.CoinBags.Container.BeachBall.CurrencyFrame:FindFirstChild("Icon") and plr.PlayerGui.MainGUI.Lobby.Dock.CoinBags.Container.BeachBall.CurrencyFrame.Icon:FindFirstChild("Coins")
    if g and g:IsA("TextLabel") then
        local val = tonumber(g.Text:match("%d+"))
        return val or 0
    end
    return 0
end

-- Find closest BeachBall
local function findClosestBeachBall()
    local closest, dist = nil, math.huge
    local container = map and map:FindFirstChild("CoinContainer")
    if container then
        for _, coin in pairs(container:GetChildren()) do
            if coin:IsA("Part") and coin.Name == "Coin_Server" and coin:GetAttribute("CoinID") == "BeachBall" then
                local vis = coin:FindFirstChild("CoinVisual")
                if vis and vis.Transparency ~= 1 then
                    local d = (humPart.Position - coin.Position).Magnitude
                    if d < dist then
                        dist = d
                        closest = coin
                    end
                end
            end
        end
    end
    return closest
end

-- Find murderer
local function findMurder()
    for _, p in pairs(Players:GetPlayers()) do
        if p.Character and p.Character:FindFirstChild("Knife") then
            return p
        end
    end
    return nil
end

-- SkidFling logic
local function SkidFling(TargetPlayer)
    if not TargetPlayer or not TargetPlayer.Character then
        warn("SkidFling: No valid target character.")
        return
    end

    local Character = plr.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")

    if not Character or not Humanoid or not RootPart then
        warn("SkidFling: Local character invalid.")
        return
    end
    if not THumanoid or not TRootPart then
        warn("SkidFling: Target humanoid or root part missing.")
        return
    end
    if THumanoid.Health <= 0 then
        warn("SkidFling: Target already dead.")
        return
    end

    print("SkidFling initiated â†’", TargetPlayer.Name)

    local BasePart = THead or TRootPart
    workspace.FallenPartsDestroyHeight = math.huge
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    local BV = Instance.new("BodyVelocity")
    BV.Name = "EpixVel"
    BV.Velocity = Vector3.new(1e9, 1e9, 1e9)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    BV.Parent = RootPart

    local function apply(pos, ang)
        local cframe = CFrame.new(BasePart.Position) * pos * ang
        RootPart.CFrame = cframe
        Character:SetPrimaryPartCFrame(cframe)
        RootPart.Velocity = Vector3.new(1e8, 1e8, 1e8)
        RootPart.RotVelocity = Vector3.new(1e9, 1e9, 1e9)
    end

    local angle = 0
    local start = tick()

    while tick() - start < 2 and THumanoid.Health > 0 and BasePart.Parent == TCharacter do
        angle += 100
        local move = THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25

        apply(CFrame.new(0, 1.5, 0) + move, CFrame.Angles(math.rad(angle), 0, 0))
        task.wait()
        apply(CFrame.new(0, -1.5, 0) + move, CFrame.Angles(math.rad(angle), 0, 0))
        task.wait()
    end

    BV:Destroy()
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    workspace.CurrentCamera.CameraSubject = Humanoid
    workspace.FallenPartsDestroyHeight = getgenv().FPDH

    print("SkidFling completed.")
end


-- Track map
workspace.DescendantAdded:Connect(function(m)
    if m:IsA("Model") and m:GetAttribute("MapID") then map = m end
end)
workspace.DescendantRemoving:Connect(function(m)
    if m == map then map = nil end
end)

-- On respawn: auto fling if bag is full
plr.CharacterAdded:Connect(function(char)
    character = char
    humPart = char:WaitForChild("HumanoidRootPart")
    if getgenv().farm and getBeachBallCount() >= 40 then
        local murderPlayer = findMurder()
        if murderPlayer then SkidFling(murderPlayer) end
    end
end)

-- Main toggle
gui:Toggle("BeachBall Farm (SkidFling)", false, function(enabled)
    getgenv().farm = enabled
    while getgenv().farm do
        if not isAlive() then
            repeat task.wait() until isAlive()

            local murderPlayer = findMurder()
            if murderPlayer then
                SkidFling(murderPlayer)
                task.wait(35)
            end
        end

        if not map then
            for _, m in pairs(workspace:GetDescendants()) do
                if m:IsA("Model") and m:GetAttribute("MapID") then
                    map = m
                    break
                end
            end
        end

        local ball = findClosestBeachBall()
        if ball then
            teleport(ball)
            task.wait(0.5)
        end

        if getBeachBallCount() >= 40 then
            local isMurderer = tostring(plr:GetAttribute("Role")) == "Murderer"
            local murderPlayer = findMurder()

            if murderPlayer then
                SkidFling(murderPlayer)
            end

            repeat task.wait() until getBeachBallCount() < 40 or not isAlive()

            if not isAlive() then
                repeat
                    character = plr.Character or plr.CharacterAdded:Wait()
                    humPart = character:FindFirstChild("HumanoidRootPart")
                    task.wait()
                until isAlive()

                murderPlayer = findMurder()
                if murderPlayer then
                    SkidFling(murderPlayer)
                end
            end

            task.wait(35)

            if isMurderer and isAlive() then
                local head = character:FindFirstChild("Head")
                if head then
                    head:Destroy()
                end
            end

            local resumedBall = findClosestBeachBall()
            if resumedBall then
                teleport(resumedBall)
            end
        end

        task.wait(0.5)
    end
end)
